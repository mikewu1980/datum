Apache Commons包含了很多开源的工具，用于解决平时编程经常会遇到的问题，减少重复劳动。

=====================================================================================================================
组件		功能介绍
BeanUtils	提供了对于JavaBean进行各种操作，克隆对象,属性等等.
Betwixt		XML与Java对象之间相互转换.
Codec		处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.
Collections	java集合框架操作.
Compress	java提供文件打包 压缩类库.
Configuration	一个java应用程序的配置管理类库.
DBCP		提供数据库连接池服务.
DbUtils		提供对jdbc 的操作封装来简化数据查询和记录读取操作.
Email		java发送邮件 对javamail的封装.
FileUpload	提供文件上传功能.
HttpClien	提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents
IO		io工具的封装.
Lang		Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.
Logging		提供的是一个Java 的日志接口.
Validator	提供了客户端和服务器端的数据验证框架.
=====================================================================================================================


=====================================================================================================================

org.apache.commons.beanutils.BeanUtils - 复制实体或某个属性；Map和Bean互转；
org.apache.commons.codec.binary.Base64 - Base64编码工具
org.apache.commons.codec.binary.StringUtils - 字符集编码工具
org.apache.commons.codec.binary.Hex - 16进制工具
org.apache.commons.codec.digest.DigestUtils - MD5、SHA1等hash工具
org.apache.commons.codec.net.URLCodec - URL编解码工具

=====================================================================================================================

org.apache.commons.collections – Commons Collections自定义的一组公用的接口和工具类
org.apache.commons.collections.bag – 实现Bag接口的一组类
org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类
org.apache.commons.collections.buffer – 实现Buffer接口的一组类
org.apache.commons.collections.collection – 实现java.util.Collection接口的一组类
org.apache.commons.collections.comparators – 实现java.util.Comparator接口的一组类
org.apache.commons.collections.functors – Commons Collections自定义的一组功能类
org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类
org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类
org.apache.commons.collections.list – 实现java.util.List接口的一组类
org.apache.commons.collections.map – 实现Map系列接口的一组类
org.apache.commons.collections.set – 实现Set系列接口的一组类

=====================================================================================================================

org.apache.commons.collections4.BidiMap;
org.apache.commons.collections4.OrderedMap;
org.apache.commons.collections4.bidimap.TreeBidiMap;
org.apache.commons.collections4.map.LinkedMap;
org.apache.commons.collections4.CollectionUtils;
org.apache.commons.collections4.MapUtils;

// 得到集合里按顺序存放的key之后的某一Key
OrderedMap map = new LinkedMap();
map.firstKey();
map.nextKey("FIVE");

// 通过key得到value，通过value得到key，将map里的key和value对调
BidiMap bidi = new TreeBidiMap();
bidi.getKey("6");
bidi.removeValue("6");
BidiMap inverse = bidi.inverseBidiMap();

// 得到两个集合中相同的元素
Collection c = CollectionUtils.retainAll(list1, list2);

=====================================================================================================================

// ZIP如下，其他类型的压缩文件同理，但在archivers包的不同的子包中
org.apache.commons.compress.archivers.zip.ZipArchiveInputStream - 解压ZIP文件
org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream - 压制ZIP文件

// 创建压缩对象
ZipArchiveEntry entry = new ZipArchiveEntry("CompressTest");
// 要压缩的文件
File f = new File("e:\\test.pdf");
FileInputStream fis = new FileInputStream(f);
// 输出的对象压缩的文件
ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(new File("e:\\test.zip"));
zipOutput.putArchiveEntry(entry);
int i = 0, j;
while((j=fis.read()) != -1) {
	zipOutput.write(j);
	i++;
	System.out.println(i);
}
zipOutput.closeArchiveEntry();
zipOutput.close();
fis.close();

=====================================================================================================================

// Configuration 用来帮助处理配置文件的，支持很多种存储方式。
1. Properties files
2. XML documents
3. Property list files (.plist)
4. JNDI
5. JDBC Datasource
6. System properties
7. Applet parameters
8. Servlet parameters

// 示例
PropertiesConfiguration config = new PropertiesConfiguration("usergui.properties");
config.setProperty("colors.background", "#000000);
config.save();
Integer integer = config.getInteger("window.width");

=====================================================================================================================

DBCP (Database Connection Pool)是一个依赖Jakarta commons-pool对象池机制的数据库连接池,Tomcat的数据源使用的就是DBCP。

org.apache.commons.pool.ObjectPool;
org.apache.commons.pool.impl.GenericObjectPool;
org.apache.commons.dbcp.ConnectionFactory;
org.apache.commons.dbcp.PoolingDataSource;
org.apache.commons.dbcp.PoolableConnectionFactory;
org.apache.commons.dbcp.DriverManagerConnectionFactory;

public static DataSource setupDataSource(String connectURI) {
	//设置连接地址
	ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(connectURI, null);
	// 创建连接工厂
	PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory);
	// 获取GenericObjectPool 连接的实例
	ObjectPool connectionPool = new GenericObjectPool(poolableConnectionFactory);
	// 创建 PoolingDriver
	PoolingDataSource dataSource = new PoolingDataSource(connectionPool);
	return dataSource;
}

=====================================================================================================================

DbUtils Apache组织提供的一个资源JDBC工具类库，它是对JDBC的简单封装，对传统操作数据库的类进行二次封装，可以把结果集转化成List。，同时也不影响程序的性能。
DbUtils类：启动类
ResultSetHandler接口：转换类型接口
MapListHandler类：实现类，把记录转化成List
BeanListHandler类：实现类，把记录转化成List，使记录为JavaBean类型的对象
Query Runner类：执行SQL语句的类

// 结果集转List
public static void main(String[] args) {
	Connection conn = null;
	String url = "jdbc:mysql://localhost:3306/ptest";
	String jdbcDriver = "com.mysql.jdbc.Driver";
	String user = "root";
	String password = "ptest";

	DbUtils.loadDriver(jdbcDriver);
	try {
		conn = DriverManager.getConnection(url, user, password);
		QueryRunner qr = new QueryRunner();
		List results = (List) qr.query(conn, "select id,name from person", new BeanListHandler(Person.class));
		for (int i = 0; i < results.size(); i++) {
			Person p = (Person) results.get(i);
			System.out.println("id:" + p.getId() + ",name:" + p.getName());
		}
	} catch (SQLException e) {
		e.printStackTrace();
	} finally {
		DbUtils.closeQuietly(conn);
	}
}

// 结果集转Map
public static void main(String[] args) {
	Connection conn = null;
	String url = "jdbc:mysql://localhost:3306/ptest";
	String jdbcDriver = "com.mysql.jdbc.Driver";
	String user = "root";
	String password = "ptest";

	DbUtils.loadDriver(jdbcDriver);

	try {
		conn = DriverManager.getConnection(url, user, password);
		QueryRunner qr = new QueryRunner();
		List results = (List) qr.query(conn, "select id,name from person", new MapListHandler());
		for (int i = 0; i < results.size(); i++) {
			Map map = (Map) results.get(i);
			System.out.println("id:" + map.get("id") + ",name:" + map.get("name"));
		}
	} catch (SQLException e) {
		e.printStackTrace();
	} finally {
		DbUtils.closeQuietly(conn);
	}
}

=====================================================================================================================

Email 提供的一个开源的API，是对javamail的封装。

// 用commons email发送邮件
public static void main(String args[]){
	Email email = new SimpleEmail();
	email.setHostName("smtp.googlemail.com");
	email.setSmtpPort(465);
	email.setAuthenticator(new DefaultAuthenticator("username", "password"));
	email.setSSLOnConnect(true);
	email.setFrom("user@gmail.com");
	email.setSubject("TestMail");
	email.setMsg("This is a test mail ... :-)");
	email.addTo("foo@bar.com");
	email.send();
}

=====================================================================================================================

FileUpload java web文件上传功能。

// 官方示例：
// 检查请求是否含有上传文件
	// Check that we have a file upload request
	boolean isMultipart = ServletFileUpload.isMultipartContent(request);

	// 现在我们得到了items的列表
	// 如果你的应用近于最简单的情况，上面的处理就够了。但我们有时候还是需要更多的控制。
	// 下面提供了几种控制选择：
	// Create a factory for disk-based file items
	DiskFileItemFactory factory = new DiskFileItemFactory();

	// Set factory constraints
	factory.setSizeThreshold(yourMaxMemorySize);
	factory.setRepository(yourTempDirectory);

	// Create a new file upload handler
	ServletFileUpload upload = new ServletFileUpload(factory);

	// 设置最大上传大小
	upload.setSizeMax(yourMaxRequestSize);

	// 解析所有请求
	List /* FileItem */ items = upload.parseRequest(request);

	// Create a factory for disk-based file items
	DiskFileItemFactory factory = new DiskFileItemFactory(yourMaxMemorySize, yourTempDirectory);

	// 一旦解析完成，你需要进一步处理item的列表。
	// Process the uploaded items
	Iterator iter = items.iterator();
	while (iter.hasNext()) {
		FileItem item = (FileItem) iter.next();
		if (item.isFormField()) {
			processFormField(item);
		} else {
			processUploadedFile(item);
		}
	}

	// 区分数据是否为简单的表单数据，如果是简单的数据：
	// processFormField
	if (item.isFormField()) {
		String name = item.getFieldName();
		String value = item.getString();
		// 省略步骤...
	}

	// 如果是提交的文件：
	// processUploadedFile
	if (!item.isFormField()) {
		String fieldName = item.getFieldName();
		String fileName = item.getName();
		String contentType = item.getContentType();
		boolean isInMemory = item.isInMemory();
		long sizeInBytes = item.getSize();
		// 省略步骤...
	}

	// 对于这些item，我们通常要把它们写入文件，或转为一个流
	// Process a file upload
	if (writeToFile) {
		File uploadedFile = new File(...);
		item.write(uploadedFile);
	} else {
		InputStream uploadedStream = item.getInputStream();
		// 省略步骤...
		uploadedStream.close();
	}

	// 或转为字节数组保存在内存中：
	// Process a file upload in memory
	byte[] data = item.get();
	// 省略步骤...
	// 如果这个文件真的很大，你可能会希望向用户报告到底传了多少到服务端，让用户了解上传的过程
	// Create a progress listener
	ProgressListener progressListener = new ProgressListener() {
		public void update(long pBytesRead, long pContentLength, int pItems) {
			System.out.println("We are currently reading item " + pItems);
			if (pContentLength == -1) {
				System.out.println("So far, " + pBytesRead + " bytes have been read.");
			} else {
				System.out.println("So far, " + pBytesRead + " of " + pContentLength + " bytes have been read.");
			}
		}
	};
	upload.setProgressListener(progressListener);

=====================================================================================================================

HttpClien 基于HttpCore实 现的一个HTTP/1.1兼容的HTTP客户端，它提供了一系列可重用的客户端身份验证、HTTP状态保持、HTTP连接管理module。

=====================================================================================================================

IO 对java.io的扩展 操作文件非常方便。

// 1．读取Stream
//标准代码：
InputStream in = new URL("http://jakarta.apache.org").openStream();
try {
	InputStreamReader inR = new InputStreamReader(in);
	BufferedReader buf = new BufferedReader(inR);
	String line;
	while ((line = buf.readLine()) != null) {
		System.out.println( line );
	}
} finally {
	in.close();
}

// 使用IOUtils
InputStream in = new URL("http://jakarta.apache.org").openStream();
try {
	System.out.println( IOUtils.toString( in ) );
} finally {
	IOUtils.closeQuietly(in);
}

// 2．读取文件
File file = new File("/commons/io/project.properties");
List lines = FileUtils.readLines(file, "UTF-8");

// 3．察看剩余空间
long freeSpace = FileSystemUtils.freeSpace("C:/");

=====================================================================================================================

Lang 主要是一些公共的工具集合，比如对字符、数组的操作等等。

org.apache.commons.lang3.ArrayUtils - 数组工具，处理数组创建、新增、删除、复制、查找、取子集、颠倒数组、数组转Map；判断是否相等、是否包含、是否为空、是否等长、是否有序。


org.apache.commons.lang3.EnumUtils - 枚举工具

org.apache.commons.lang3.StringUtils - 字符串工具
// 截取从from开始字符串
StringUtils.substringAfter("SELECT * FROM PERSON ", "from");
// 判断该字符串是不是为数字(0~9)组成，如果是，返回true。但该方法不识别有小数点和请注意
StringUtils.isNumeric("454534");

org.apache.commons.lang3.math.NumberUtils - 数字工具，处理数字比较等操作
// 判断是否为数字
NumberUtils.isNumber("6");


org.apache.commons.lang3.RandomUtils - 随机工具






